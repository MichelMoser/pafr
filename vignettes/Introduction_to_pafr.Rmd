---
title: "Using pafr to read, manipulate and plot genome alignments in the PAF format"
author: "David Winter"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{pafr_tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  fig.height=4,
  fig.width=6,
  fig.align = 'center'
)
```




## Reading data with `read_paf`

`pafr` deals with data stored in the Pairwise mApping Format (PAF), as 
used by `minimap2` and other whole-genome aligners. PAF is a plain text
tabular format where each row represents an alignment between two sequences. 
Each `.paf` file has at least the following 12 columns.


| **Column** | **Data type** | **Description**
|--------|-----------|---------------------------------------------------------|
| 1      | string    | Query sequence name                                     |
| 2      | int       | Query sequence length                                   |
| 3      | int       | Query start coordinate (0-based)                        |
| 4      | int       | Query end coordinate (0-based)                          |
| 5      | char      | ‘+’ if query/target on the same strand; ‘-’ if opposite |
| 6      | string    | Target sequence name                                    |
| 7      | int       | Target sequence length                                  |
| 8      | int       | Target start coordinate on the original strand          |
| 9      | int       | Target end coordinate on the original strand            |
| 10     | int       | Number of matching bases in the mapping                 |
| 11     | int       | Number bases, including gaps, in the mapping            |
| 12     | int       | Mapping quality (0-255 with 255 for missing)            |

In addition, each row can have a variable number of 'tags', which share a simliar
format to those used SAM files [See the SAM specification (pdf)](https://samtools.github.io/hts-specs/SAMtags.pdf).

`pafr` provides the function `read_paf` to read alignments into an R session.


```{r read}
library(pafr)
path_to_fungal_alignment <- system.file("extdata", "fungi.paf", package = "pafr")
ali <- read_paf(path_to_fungal_alignment)
```

By default, the object returned by read_paf behaves almost exactly like a base R
`data.frame`. In fact, the only difference is this object prints a nice summary
of the object content when called directly or printed (rather than the thousands
of lines it might contain):


```{r print}
ali
```

In this case there is a total of 35Mb of aligned-genome, coming from 8 query
and 8 target sequences.`read_paf` gives the 12 core columns of the PAF format 
the following column names.


| Column | Name   | Data type | Description                                             |
|--------|--------|-----------|---------------------------------------------------------|
| 1      | qname  | string    | Query sequence name                                     |
| 2      | qlen   | int       | Query sequence length                                   |
| 3      | qstart | int       | Query start coordinate (0-based)                        |
| 4      | qend   | int       | Query end coordinate (0-based)                          |
| 5      | strand | char      | ‘+’ if query/target on the same strand; ‘-’ if opposite |
| 6      | tname  | string    | Target sequence name                                    |
| 7      | tlen   | int       | Target sequence length                                  |
| 8      | tstart | int       | Target start coordinate on the original strand          |
| 9      | tend   | int       | Target end coordinate on the original strand            |
| 10     | nmatch | int       | Number of matching bases in the mapping                 |
| 11     | alen   | int       | Number bases, including gaps, in the mapping            |
| 12     | mapq   | int       | Mapping quality (0-255 with 255 for missing)            |

In addition, any tags present in the file will be included as a column. The tags
used by `minimap2` [are documented
here](https://lh3.github.io/minimap2/minimap2.html) or in the man page for that
program. One interesting tag for this alignment is `dv`, which encodes the
approximate per-base difference between query and target sequence. We can use
this tag to visualize the relatinship between alignment-length and sequence
divergence. Because the alignment data is stored in a `data.frame` we can pass
it directly to `ggplot2`:


```{r, alen}
library(ggplot2)
library(ggpubr)

ggplot(ali, aes(alen, dv)) + 
    geom_point(alpha=0.6, colour="steelblue", size=2) + 
    scale_x_continuous("Alignment length (kb)", label =  function(x) x/ 1e3) +
    scale_y_continuous("Per base divergence") + 
    theme_pubr()
```

There are a lot of short alignments, some of which are very
divergent. But there are also so very long alignments, which all show high
similarity. 

Because the `pafr` object is effectively a `data.frame`, we can use normal R
functions to inspect or analyse it. For example, let's calculate the mean
divergence-level for alignments featuring each query sequence.

```{r, compare_q}
by_q <- aggregate(dv ~ qname, data=ali, FUN=mean)
knitr::kable(by_q)
```

Interestingly enough, `Q_chrm` is the mitochondrial genome, so appears the
mitochrondial genome diplays less diveregnce than any of the chromosomes in this 
case.


## Filtering and subsetting alignments

Often the first thing you will want to do after reading in some data is get rid
of low-quality, short and otherwise not-ideal alignments. `minimap2` uses the 
`tp` (type of alignment) tag to mark secondary alignments (i.e. possible
alignments between the query and target sequence that are not the best possible
alignment for those regions). The function `filter_secondary_alignments` removes
non-primary alignments from a `pafr object`. Let's use it to filter our `ali`
object and see how many alignments (i.e. rows of data) we lose as a result:

```{r, prim_only}
prim_alignment <- filter_secondary_alignments(ali)
nrow(ali) - nrow(prim_alignment)
```

In some cases you might want to remove alignments with low mapping quality, high
divergence, short length or some other property. Again, because the `pafr`
object behaves like a  `data.frame` you can use your favourite base `R` or
`tidyverse` functions to do this. Here I remove short alignments and those with
a low mapping quality score:


```{r, remove_short}
long_ali <- subset(ali, alen > 1e4 & mapq > 40)
long_ali
```

Note, this has removed quite a lot of data (thousands of alignments and ~ 10Mb
of sequence).

## Plotting alignments 

One of the major aims of `pafr` is to generate compelling visualisatoins of 
genomic alignments. To this end, the he package implements three types of 
genomic visualizatoin, making use of the `ggplot2` plotting environment. Alhough 
`ggplot2` is powerful visualizatoin tool, we found producing high-quality plots 
of genome alignments was difficult, requring the use of many different layers
and transformations to datasets. The visualisation functions provided by `pafr`
automate the process of transoformating data and adding layers to a plot. Each
of tehse functoins returns `ggplot2` plots, which can then be modified by the
addition of ggplot layers, scales and themes.

### Dotplot

Often the most useful visualization of a genome alignment is the
[dotplot](https://en.wikipedia.org/wiki/Dot_plot_(bioinformatics)). `pafr` makes
it easy to produce one of these from a .paf alignment: 

```{r dotplot_plain, fig.height=6}
dotplot(prim_alignment)
```

#### Altering the order of sequences in the dotplot

The defaul plot is quite bare, with each aligned segment shown as a dark line
and the borders of the sequences in the query and target genomes are dashed
lines. Additional arguments to `dotplot` allow us to modify the plot. In this
case we can add labels for each query and target squence (`label_seqs`) and
changes the order in which target sequences appear. Because the dotplot being
produced here is a ggplot object, we can use `theme_bw()` to change the plots
theme too.


```{r dot_qstart, fig.height=6}
dotplot(prim_alignment, label_seqs=TRUE, order_by="qstart") + theme_bw()
```

The argument `order_by` takes three possible values: "size", "qstart" or 
"provided". "Size"(the default value) simply lines up query and target sequences
from largest to smallest. "qstart" keeps the query sequences ordered by size,
but rearranges the targets by where they match to query sequences. For
example, `T_chr5` is moved to the second sequence in the above plot, as it
matches to the first query chromosome. If `ordered_by` is set to "provided" you
need provide a list with two elements (the order of query and then target
sequences) to the function. This approach can also be used to down-sample an
alignment to only a few focal sequences.


```{r dot_provided, fig.height=6}
to_keep <- list(
        c("Q_chr1", "Q_chr5", "Q_chr4", "Q_chr6"),
        c("T_chr2", "T_chr5", "T_chr3", "T_chr6")
)
dotplot(prim_alignment, label_seqs=TRUE, order_by="provided", ordering=to_keep)
```

#### Adding annotations


You may have additional information about one or both of your genomes that you
want to use to annotate your dotplots. In this case, we know the locations of
the centromeres in the query genome. We can use `read_bed` to load these
locations.

```{r}
path_to_centro <- system.file("extdata", "Q_centro.bed", package = "pafr")
centro <- read_bed(path_to_centro)
knitr::kable(head(centro))
```

In `ggplot` style, we use the `+` symbol to add the results of `highlight_query`
to a dotplot. Note, in order for the plot to work both the `ordered_by` and
`ali` arguments must match between the call to `dotplot` and `highlight_query`.

```{r highlight, fig.height=6}
dotplot(prim_alignment, "qstart") + 
    highlight_query(ali=prim_alignment, bed=centro, ordered_by="qstart")
```

It's not apparent from the very small intervals plotted above, but 'highlights'
here are a filled rectangle. Plotting a larger rectangle for the target genome
makes it more clear.

```{r highlight_t, fig.height=6}
interval <- data.frame(chrom="T_chr3", start = 2000000, end= 3000000)
dotplot(prim_alignment, label_seqs=TRUE) + 
    highlight_target(prim_alignment, interval)
```

### Synteny plot

The dotplot gives us a 'whole genome' view of a genomic alignment. Very often we
will also want to zoom down to look at how regions of two particular chromosomes
are aligned to each other. The function `plot_synteny` provides a way to
visualize alignments at this level. Lets compare regions of query chromosome 3
and target chromosome 4.

```{r, fig.height = 4}
plot_synteny(long_ali, q_chrom="Q_chr3", t_chrom="T_chr4", centre=TRUE) +
    theme_bw()
```

In this plot, each sequence is represented as a white box and each alignment
is a grey segment connecting the regions of those sequences that align to each
other. In this case, the alignment is quite straightforward. The plot looks less
clear when most of the alignments are in reverse-and-complement.

```{r, fig.height = 4}
plot_synteny(long_ali, q_chrom="Q_chr5", t_chrom="T_chr5", centre=TRUE) +
    theme_bw()

```

The simple answer in these cases is to set the argument `rc` to `TRUE`, forcing
the target sequence to be flipped.

```{r, fig.height = 4}
plot_synteny(long_ali, q_chrom="Q_chr5", t_chrom="T_chr5", centre=TRUE, rc=TRUE) +
    theme_bw()
```
### Coverage plot

The function `plot_coverage` gives a useful way to see how much of a given
genome is included in a genome alignment. By default, it displays each sequence
in the target chromosome as a rectangular box, with shaded regions represented
parts of the target genome that are included in an alignment:

```{r,cov_plot}
plot_coverage(prim_alignment)   
```

It is also possible to produce the same plot using the query genome as the
reference.


```{r, cov_target}
plot_coverage(prim_alignment, target=FALSE)   
```


#### Coverage by query sequence

Sometimes, in addition to knowing how much of a given genome is represented in a
whole genome alignment, it is interesting to know which sequences from the other
genome are aligning. For example, we might want to 'paint' regions of the target
sequence by which query seqeunce they form an alignment to. The `plot_coverage`
function can shade the alignment blocks it produces according to any column in
the alignment. Here is how we do it for query sequence name (i.e. the `qname`
column), taking advantage of `ggplot`'s `scale_colour_brewer` to use a nice
palete.


```{r, cov_colourful}
plot_coverage(prim_alignment, fill='qname') + scale_fill_brewer(palette="Set1")
```
